// Generated by gencpp from file integrated_navigation_reader/SPANLog_ExtendedSolutionStatus.msg
// DO NOT EDIT!


#ifndef INTEGRATED_NAVIGATION_READER_MESSAGE_SPANLOG_EXTENDEDSOLUTIONSTATUS_H
#define INTEGRATED_NAVIGATION_READER_MESSAGE_SPANLOG_EXTENDEDSOLUTIONSTATUS_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace integrated_navigation_reader
{
template <class ContainerAllocator>
struct SPANLog_ExtendedSolutionStatus_
{
  typedef SPANLog_ExtendedSolutionStatus_<ContainerAllocator> Type;

  SPANLog_ExtendedSolutionStatus_()
    : position_update(false)
    , phase_update(false)
    , zero_velocity_update(false)
    , wheel_sensor_update(false)
    , ALIGN_heading_update(false)
    , external_position_update(false)
    , INS_solution_convergence_flag(false)
    , doppler_update(false)
    , pseudorange_update(false)
    , velocity_update(false)
    , reserved_bit_10(false)
    , dead_reckoning_update(false)
    , phase_wind_up_update(false)
    , course_over_ground_update(false)
    , external_velocity_update(false)
    , external_attitude_update(false)
    , external_heading_update(false)
    , external_height_update(false)
    , reserved_bit_18(false)
    , reserved_bit_19(false)
    , reserved_bit_20(false)
    , reserved_bit_21(false)
    , secondary_INS_solution(false)
    , reserved_bit_23(false)
    , turn_on_biases_estimated(false)
    , alignment_direction_verified(false)
    , alignment_indication(0)
    , NVM_seed_indication(0)  {
    }
  SPANLog_ExtendedSolutionStatus_(const ContainerAllocator& _alloc)
    : position_update(false)
    , phase_update(false)
    , zero_velocity_update(false)
    , wheel_sensor_update(false)
    , ALIGN_heading_update(false)
    , external_position_update(false)
    , INS_solution_convergence_flag(false)
    , doppler_update(false)
    , pseudorange_update(false)
    , velocity_update(false)
    , reserved_bit_10(false)
    , dead_reckoning_update(false)
    , phase_wind_up_update(false)
    , course_over_ground_update(false)
    , external_velocity_update(false)
    , external_attitude_update(false)
    , external_heading_update(false)
    , external_height_update(false)
    , reserved_bit_18(false)
    , reserved_bit_19(false)
    , reserved_bit_20(false)
    , reserved_bit_21(false)
    , secondary_INS_solution(false)
    , reserved_bit_23(false)
    , turn_on_biases_estimated(false)
    , alignment_direction_verified(false)
    , alignment_indication(0)
    , NVM_seed_indication(0)  {
  (void)_alloc;
    }



   typedef uint8_t _position_update_type;
  _position_update_type position_update;

   typedef uint8_t _phase_update_type;
  _phase_update_type phase_update;

   typedef uint8_t _zero_velocity_update_type;
  _zero_velocity_update_type zero_velocity_update;

   typedef uint8_t _wheel_sensor_update_type;
  _wheel_sensor_update_type wheel_sensor_update;

   typedef uint8_t _ALIGN_heading_update_type;
  _ALIGN_heading_update_type ALIGN_heading_update;

   typedef uint8_t _external_position_update_type;
  _external_position_update_type external_position_update;

   typedef uint8_t _INS_solution_convergence_flag_type;
  _INS_solution_convergence_flag_type INS_solution_convergence_flag;

   typedef uint8_t _doppler_update_type;
  _doppler_update_type doppler_update;

   typedef uint8_t _pseudorange_update_type;
  _pseudorange_update_type pseudorange_update;

   typedef uint8_t _velocity_update_type;
  _velocity_update_type velocity_update;

   typedef uint8_t _reserved_bit_10_type;
  _reserved_bit_10_type reserved_bit_10;

   typedef uint8_t _dead_reckoning_update_type;
  _dead_reckoning_update_type dead_reckoning_update;

   typedef uint8_t _phase_wind_up_update_type;
  _phase_wind_up_update_type phase_wind_up_update;

   typedef uint8_t _course_over_ground_update_type;
  _course_over_ground_update_type course_over_ground_update;

   typedef uint8_t _external_velocity_update_type;
  _external_velocity_update_type external_velocity_update;

   typedef uint8_t _external_attitude_update_type;
  _external_attitude_update_type external_attitude_update;

   typedef uint8_t _external_heading_update_type;
  _external_heading_update_type external_heading_update;

   typedef uint8_t _external_height_update_type;
  _external_height_update_type external_height_update;

   typedef uint8_t _reserved_bit_18_type;
  _reserved_bit_18_type reserved_bit_18;

   typedef uint8_t _reserved_bit_19_type;
  _reserved_bit_19_type reserved_bit_19;

   typedef uint8_t _reserved_bit_20_type;
  _reserved_bit_20_type reserved_bit_20;

   typedef uint8_t _reserved_bit_21_type;
  _reserved_bit_21_type reserved_bit_21;

   typedef uint8_t _secondary_INS_solution_type;
  _secondary_INS_solution_type secondary_INS_solution;

   typedef uint8_t _reserved_bit_23_type;
  _reserved_bit_23_type reserved_bit_23;

   typedef uint8_t _turn_on_biases_estimated_type;
  _turn_on_biases_estimated_type turn_on_biases_estimated;

   typedef uint8_t _alignment_direction_verified_type;
  _alignment_direction_verified_type alignment_direction_verified;

   typedef uint8_t _alignment_indication_type;
  _alignment_indication_type alignment_indication;

   typedef uint8_t _NVM_seed_indication_type;
  _NVM_seed_indication_type NVM_seed_indication;



// reducing the odds to have name collisions with Windows.h 
#if defined(_WIN32) && defined(Unused)
  #undef Unused
#endif
#if defined(_WIN32) && defined(Used)
  #undef Used
#endif
#if defined(_WIN32) && defined(Not_converged)
  #undef Not_converged
#endif
#if defined(_WIN32) && defined(Converged)
  #undef Converged
#endif
#if defined(_WIN32) && defined(Biases_not_estimated)
  #undef Biases_not_estimated
#endif
#if defined(_WIN32) && defined(Biases_estimated)
  #undef Biases_estimated
#endif
#if defined(_WIN32) && defined(Not_verified)
  #undef Not_verified
#endif
#if defined(_WIN32) && defined(Verified)
  #undef Verified
#endif
#if defined(_WIN32) && defined(Incomplete_Alignment)
  #undef Incomplete_Alignment
#endif
#if defined(_WIN32) && defined(Static)
  #undef Static
#endif
#if defined(_WIN32) && defined(Kinematic)
  #undef Kinematic
#endif
#if defined(_WIN32) && defined(Dual_Antenna)
  #undef Dual_Antenna
#endif
#if defined(_WIN32) && defined(User_Command)
  #undef User_Command
#endif
#if defined(_WIN32) && defined(NVM_Seed)
  #undef NVM_Seed
#endif
#if defined(_WIN32) && defined(Not_Injected)
  #undef Not_Injected
#endif
#if defined(_WIN32) && defined(Valid_Not_Found)
  #undef Valid_Not_Found
#endif
#if defined(_WIN32) && defined(Failed_Validation_and_Discarded)
  #undef Failed_Validation_and_Discarded
#endif
#if defined(_WIN32) && defined(Awaiting_Validation)
  #undef Awaiting_Validation
#endif
#if defined(_WIN32) && defined(Alignment_Data_Injected)
  #undef Alignment_Data_Injected
#endif
#if defined(_WIN32) && defined(Ignored)
  #undef Ignored
#endif
#if defined(_WIN32) && defined(Error_Model_Data_Injected)
  #undef Error_Model_Data_Injected
#endif

  enum {
    Incomplete_Alignment = 0u,
    Static = 1u,
    Kinematic = 2u,
    Dual_Antenna = 3u,
    User_Command = 4u,
    NVM_Seed = 5u,
    Not_Injected = 0u,
    Valid_Not_Found = 1u,
    Failed_Validation_and_Discarded = 2u,
    Awaiting_Validation = 3u,
    Alignment_Data_Injected = 4u,
    Ignored = 5u,
    Error_Model_Data_Injected = 6u,
  };

  static const uint8_t Unused;
  static const uint8_t Used;
  static const uint8_t Not_converged;
  static const uint8_t Converged;
  static const uint8_t Biases_not_estimated;
  static const uint8_t Biases_estimated;
  static const uint8_t Not_verified;
  static const uint8_t Verified;

  typedef boost::shared_ptr< ::integrated_navigation_reader::SPANLog_ExtendedSolutionStatus_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::integrated_navigation_reader::SPANLog_ExtendedSolutionStatus_<ContainerAllocator> const> ConstPtr;

}; // struct SPANLog_ExtendedSolutionStatus_

typedef ::integrated_navigation_reader::SPANLog_ExtendedSolutionStatus_<std::allocator<void> > SPANLog_ExtendedSolutionStatus;

typedef boost::shared_ptr< ::integrated_navigation_reader::SPANLog_ExtendedSolutionStatus > SPANLog_ExtendedSolutionStatusPtr;
typedef boost::shared_ptr< ::integrated_navigation_reader::SPANLog_ExtendedSolutionStatus const> SPANLog_ExtendedSolutionStatusConstPtr;

// constants requiring out of line definition

   
   template<typename ContainerAllocator> const uint8_t
      SPANLog_ExtendedSolutionStatus_<ContainerAllocator>::Unused =
        
           0
        
        ;
   

   
   template<typename ContainerAllocator> const uint8_t
      SPANLog_ExtendedSolutionStatus_<ContainerAllocator>::Used =
        
           1
        
        ;
   

   
   template<typename ContainerAllocator> const uint8_t
      SPANLog_ExtendedSolutionStatus_<ContainerAllocator>::Not_converged =
        
           0
        
        ;
   

   
   template<typename ContainerAllocator> const uint8_t
      SPANLog_ExtendedSolutionStatus_<ContainerAllocator>::Converged =
        
           1
        
        ;
   

   
   template<typename ContainerAllocator> const uint8_t
      SPANLog_ExtendedSolutionStatus_<ContainerAllocator>::Biases_not_estimated =
        
           0
        
        ;
   

   
   template<typename ContainerAllocator> const uint8_t
      SPANLog_ExtendedSolutionStatus_<ContainerAllocator>::Biases_estimated =
        
           1
        
        ;
   

   
   template<typename ContainerAllocator> const uint8_t
      SPANLog_ExtendedSolutionStatus_<ContainerAllocator>::Not_verified =
        
           0
        
        ;
   

   
   template<typename ContainerAllocator> const uint8_t
      SPANLog_ExtendedSolutionStatus_<ContainerAllocator>::Verified =
        
           1
        
        ;
   

   

   

   

   

   

   

   

   

   

   

   

   

   



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::integrated_navigation_reader::SPANLog_ExtendedSolutionStatus_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::integrated_navigation_reader::SPANLog_ExtendedSolutionStatus_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::integrated_navigation_reader::SPANLog_ExtendedSolutionStatus_<ContainerAllocator1> & lhs, const ::integrated_navigation_reader::SPANLog_ExtendedSolutionStatus_<ContainerAllocator2> & rhs)
{
  return lhs.position_update == rhs.position_update &&
    lhs.phase_update == rhs.phase_update &&
    lhs.zero_velocity_update == rhs.zero_velocity_update &&
    lhs.wheel_sensor_update == rhs.wheel_sensor_update &&
    lhs.ALIGN_heading_update == rhs.ALIGN_heading_update &&
    lhs.external_position_update == rhs.external_position_update &&
    lhs.INS_solution_convergence_flag == rhs.INS_solution_convergence_flag &&
    lhs.doppler_update == rhs.doppler_update &&
    lhs.pseudorange_update == rhs.pseudorange_update &&
    lhs.velocity_update == rhs.velocity_update &&
    lhs.reserved_bit_10 == rhs.reserved_bit_10 &&
    lhs.dead_reckoning_update == rhs.dead_reckoning_update &&
    lhs.phase_wind_up_update == rhs.phase_wind_up_update &&
    lhs.course_over_ground_update == rhs.course_over_ground_update &&
    lhs.external_velocity_update == rhs.external_velocity_update &&
    lhs.external_attitude_update == rhs.external_attitude_update &&
    lhs.external_heading_update == rhs.external_heading_update &&
    lhs.external_height_update == rhs.external_height_update &&
    lhs.reserved_bit_18 == rhs.reserved_bit_18 &&
    lhs.reserved_bit_19 == rhs.reserved_bit_19 &&
    lhs.reserved_bit_20 == rhs.reserved_bit_20 &&
    lhs.reserved_bit_21 == rhs.reserved_bit_21 &&
    lhs.secondary_INS_solution == rhs.secondary_INS_solution &&
    lhs.reserved_bit_23 == rhs.reserved_bit_23 &&
    lhs.turn_on_biases_estimated == rhs.turn_on_biases_estimated &&
    lhs.alignment_direction_verified == rhs.alignment_direction_verified &&
    lhs.alignment_indication == rhs.alignment_indication &&
    lhs.NVM_seed_indication == rhs.NVM_seed_indication;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::integrated_navigation_reader::SPANLog_ExtendedSolutionStatus_<ContainerAllocator1> & lhs, const ::integrated_navigation_reader::SPANLog_ExtendedSolutionStatus_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace integrated_navigation_reader

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsFixedSize< ::integrated_navigation_reader::SPANLog_ExtendedSolutionStatus_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::integrated_navigation_reader::SPANLog_ExtendedSolutionStatus_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::integrated_navigation_reader::SPANLog_ExtendedSolutionStatus_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::integrated_navigation_reader::SPANLog_ExtendedSolutionStatus_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::integrated_navigation_reader::SPANLog_ExtendedSolutionStatus_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::integrated_navigation_reader::SPANLog_ExtendedSolutionStatus_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::integrated_navigation_reader::SPANLog_ExtendedSolutionStatus_<ContainerAllocator> >
{
  static const char* value()
  {
    return "80fe8c6d48ba8a24e35b2a815cb6288a";
  }

  static const char* value(const ::integrated_navigation_reader::SPANLog_ExtendedSolutionStatus_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x80fe8c6d48ba8a24ULL;
  static const uint64_t static_value2 = 0xe35b2a815cb6288aULL;
};

template<class ContainerAllocator>
struct DataType< ::integrated_navigation_reader::SPANLog_ExtendedSolutionStatus_<ContainerAllocator> >
{
  static const char* value()
  {
    return "integrated_navigation_reader/SPANLog_ExtendedSolutionStatus";
  }

  static const char* value(const ::integrated_navigation_reader::SPANLog_ExtendedSolutionStatus_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::integrated_navigation_reader::SPANLog_ExtendedSolutionStatus_<ContainerAllocator> >
{
  static const char* value()
  {
    return "# Solution status - page 1060\n"
"\n"
"bool Unused = 0\n"
"bool Used = 1\n"
"\n"
"# N0\n"
"bool position_update\n"
"bool phase_update\n"
"bool zero_velocity_update\n"
"bool wheel_sensor_update\n"
"\n"
"# N1\n"
"bool ALIGN_heading_update\n"
"bool external_position_update\n"
"\n"
"bool Not_converged = 0\n"
"bool Converged = 1\n"
"bool INS_solution_convergence_flag\n"
"\n"
"bool doppler_update\n"
"\n"
"# N2\n"
"bool pseudorange_update\n"
"bool velocity_update\n"
"bool reserved_bit_10\n"
"bool dead_reckoning_update\n"
"\n"
"# N3\n"
"bool phase_wind_up_update\n"
"bool course_over_ground_update\n"
"bool external_velocity_update\n"
"bool external_attitude_update\n"
"\n"
"# N4\n"
"bool external_heading_update\n"
"bool external_height_update\n"
"bool reserved_bit_18\n"
"bool reserved_bit_19\n"
"\n"
"# N5\n"
"bool reserved_bit_20\n"
"bool reserved_bit_21\n"
"\n"
"bool secondary_INS_solution\n"
"bool reserved_bit_23\n"
"\n"
"# N6-7\n"
"bool Biases_not_estimated = 0\n"
"bool Biases_estimated = 1\n"
"bool turn_on_biases_estimated\n"
"\n"
"bool Not_verified = 0\n"
"bool Verified = 1\n"
"bool alignment_direction_verified\n"
"\n"
"uint8 Incomplete_Alignment = 0\n"
"uint8 Static = 1\n"
"uint8 Kinematic = 2\n"
"uint8 Dual_Antenna = 3\n"
"uint8 User_Command = 4\n"
"uint8 NVM_Seed = 5\n"
"uint8 alignment_indication\n"
"\n"
"uint8 Not_Injected = 0\n"
"uint8 Valid_Not_Found = 1\n"
"uint8 Failed_Validation_and_Discarded = 2\n"
"uint8 Awaiting_Validation = 3\n"
"uint8 Alignment_Data_Injected = 4\n"
"uint8 Ignored = 5\n"
"uint8 Error_Model_Data_Injected = 6\n"
"uint8 NVM_seed_indication\n"
;
  }

  static const char* value(const ::integrated_navigation_reader::SPANLog_ExtendedSolutionStatus_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::integrated_navigation_reader::SPANLog_ExtendedSolutionStatus_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.position_update);
      stream.next(m.phase_update);
      stream.next(m.zero_velocity_update);
      stream.next(m.wheel_sensor_update);
      stream.next(m.ALIGN_heading_update);
      stream.next(m.external_position_update);
      stream.next(m.INS_solution_convergence_flag);
      stream.next(m.doppler_update);
      stream.next(m.pseudorange_update);
      stream.next(m.velocity_update);
      stream.next(m.reserved_bit_10);
      stream.next(m.dead_reckoning_update);
      stream.next(m.phase_wind_up_update);
      stream.next(m.course_over_ground_update);
      stream.next(m.external_velocity_update);
      stream.next(m.external_attitude_update);
      stream.next(m.external_heading_update);
      stream.next(m.external_height_update);
      stream.next(m.reserved_bit_18);
      stream.next(m.reserved_bit_19);
      stream.next(m.reserved_bit_20);
      stream.next(m.reserved_bit_21);
      stream.next(m.secondary_INS_solution);
      stream.next(m.reserved_bit_23);
      stream.next(m.turn_on_biases_estimated);
      stream.next(m.alignment_direction_verified);
      stream.next(m.alignment_indication);
      stream.next(m.NVM_seed_indication);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct SPANLog_ExtendedSolutionStatus_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::integrated_navigation_reader::SPANLog_ExtendedSolutionStatus_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::integrated_navigation_reader::SPANLog_ExtendedSolutionStatus_<ContainerAllocator>& v)
  {
    s << indent << "position_update: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.position_update);
    s << indent << "phase_update: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.phase_update);
    s << indent << "zero_velocity_update: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.zero_velocity_update);
    s << indent << "wheel_sensor_update: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.wheel_sensor_update);
    s << indent << "ALIGN_heading_update: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.ALIGN_heading_update);
    s << indent << "external_position_update: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.external_position_update);
    s << indent << "INS_solution_convergence_flag: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.INS_solution_convergence_flag);
    s << indent << "doppler_update: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.doppler_update);
    s << indent << "pseudorange_update: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.pseudorange_update);
    s << indent << "velocity_update: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.velocity_update);
    s << indent << "reserved_bit_10: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.reserved_bit_10);
    s << indent << "dead_reckoning_update: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.dead_reckoning_update);
    s << indent << "phase_wind_up_update: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.phase_wind_up_update);
    s << indent << "course_over_ground_update: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.course_over_ground_update);
    s << indent << "external_velocity_update: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.external_velocity_update);
    s << indent << "external_attitude_update: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.external_attitude_update);
    s << indent << "external_heading_update: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.external_heading_update);
    s << indent << "external_height_update: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.external_height_update);
    s << indent << "reserved_bit_18: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.reserved_bit_18);
    s << indent << "reserved_bit_19: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.reserved_bit_19);
    s << indent << "reserved_bit_20: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.reserved_bit_20);
    s << indent << "reserved_bit_21: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.reserved_bit_21);
    s << indent << "secondary_INS_solution: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.secondary_INS_solution);
    s << indent << "reserved_bit_23: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.reserved_bit_23);
    s << indent << "turn_on_biases_estimated: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.turn_on_biases_estimated);
    s << indent << "alignment_direction_verified: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.alignment_direction_verified);
    s << indent << "alignment_indication: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.alignment_indication);
    s << indent << "NVM_seed_indication: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.NVM_seed_indication);
  }
};

} // namespace message_operations
} // namespace ros

#endif // INTEGRATED_NAVIGATION_READER_MESSAGE_SPANLOG_EXTENDEDSOLUTIONSTATUS_H
