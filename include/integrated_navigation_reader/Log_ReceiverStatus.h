// Generated by gencpp from file integrated_navigation_reader/Log_ReceiverStatus.msg
// DO NOT EDIT!


#ifndef INTEGRATED_NAVIGATION_READER_MESSAGE_LOG_RECEIVERSTATUS_H
#define INTEGRATED_NAVIGATION_READER_MESSAGE_LOG_RECEIVERSTATUS_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace integrated_navigation_reader
{
template <class ContainerAllocator>
struct Log_ReceiverStatus_
{
  typedef Log_ReceiverStatus_<ContainerAllocator> Type;

  Log_ReceiverStatus_()
    : error_flag(false)
    , temperature_status(false)
    , voltage_supply_status(false)
    , primary_antenna_power_status(false)
    , LNA_failure(false)
    , primary_antenna_open_circuit_flag(false)
    , primary_antenna_short_circuit_flag(false)
    , CPU_overload_flag(false)
    , COM_port_transmit_buffer_overrun(false)
    , spoofing_detection_status(false)
    , reserved(false)
    , link_overrun_flag(false)
    , input_overrun_flag(false)
    , aux_transmit_overrun_flag(false)
    , antenna_gain_state(false)
    , jammer_detected(false)
    , INS_reset_flag(false)
    , IMU_communication_failure(false)
    , GPS_almanac_flag_UTC_known(false)
    , position_solution_flag(false)
    , position_fixed_flag(false)
    , clock_steering_status(false)
    , clock_model_flag(false)
    , external_oscillator_locked_flag(false)
    , software_resource(false)
    , status_error_format_version_bit(false)
    , version_bit_1(false)
    , tracking_mode(false)
    , digital_filtering_enabled(false)
    , auxiliary_3_status_event_flag(false)
    , auxiliary_2_status_event_flag(false)
    , auxiliary_1_status_event_flag(false)  {
    }
  Log_ReceiverStatus_(const ContainerAllocator& _alloc)
    : error_flag(false)
    , temperature_status(false)
    , voltage_supply_status(false)
    , primary_antenna_power_status(false)
    , LNA_failure(false)
    , primary_antenna_open_circuit_flag(false)
    , primary_antenna_short_circuit_flag(false)
    , CPU_overload_flag(false)
    , COM_port_transmit_buffer_overrun(false)
    , spoofing_detection_status(false)
    , reserved(false)
    , link_overrun_flag(false)
    , input_overrun_flag(false)
    , aux_transmit_overrun_flag(false)
    , antenna_gain_state(false)
    , jammer_detected(false)
    , INS_reset_flag(false)
    , IMU_communication_failure(false)
    , GPS_almanac_flag_UTC_known(false)
    , position_solution_flag(false)
    , position_fixed_flag(false)
    , clock_steering_status(false)
    , clock_model_flag(false)
    , external_oscillator_locked_flag(false)
    , software_resource(false)
    , status_error_format_version_bit(false)
    , version_bit_1(false)
    , tracking_mode(false)
    , digital_filtering_enabled(false)
    , auxiliary_3_status_event_flag(false)
    , auxiliary_2_status_event_flag(false)
    , auxiliary_1_status_event_flag(false)  {
  (void)_alloc;
    }



   typedef uint8_t _error_flag_type;
  _error_flag_type error_flag;

   typedef uint8_t _temperature_status_type;
  _temperature_status_type temperature_status;

   typedef uint8_t _voltage_supply_status_type;
  _voltage_supply_status_type voltage_supply_status;

   typedef uint8_t _primary_antenna_power_status_type;
  _primary_antenna_power_status_type primary_antenna_power_status;

   typedef uint8_t _LNA_failure_type;
  _LNA_failure_type LNA_failure;

   typedef uint8_t _primary_antenna_open_circuit_flag_type;
  _primary_antenna_open_circuit_flag_type primary_antenna_open_circuit_flag;

   typedef uint8_t _primary_antenna_short_circuit_flag_type;
  _primary_antenna_short_circuit_flag_type primary_antenna_short_circuit_flag;

   typedef uint8_t _CPU_overload_flag_type;
  _CPU_overload_flag_type CPU_overload_flag;

   typedef uint8_t _COM_port_transmit_buffer_overrun_type;
  _COM_port_transmit_buffer_overrun_type COM_port_transmit_buffer_overrun;

   typedef uint8_t _spoofing_detection_status_type;
  _spoofing_detection_status_type spoofing_detection_status;

   typedef uint8_t _reserved_type;
  _reserved_type reserved;

   typedef uint8_t _link_overrun_flag_type;
  _link_overrun_flag_type link_overrun_flag;

   typedef uint8_t _input_overrun_flag_type;
  _input_overrun_flag_type input_overrun_flag;

   typedef uint8_t _aux_transmit_overrun_flag_type;
  _aux_transmit_overrun_flag_type aux_transmit_overrun_flag;

   typedef uint8_t _antenna_gain_state_type;
  _antenna_gain_state_type antenna_gain_state;

   typedef uint8_t _jammer_detected_type;
  _jammer_detected_type jammer_detected;

   typedef uint8_t _INS_reset_flag_type;
  _INS_reset_flag_type INS_reset_flag;

   typedef uint8_t _IMU_communication_failure_type;
  _IMU_communication_failure_type IMU_communication_failure;

   typedef uint8_t _GPS_almanac_flag_UTC_known_type;
  _GPS_almanac_flag_UTC_known_type GPS_almanac_flag_UTC_known;

   typedef uint8_t _position_solution_flag_type;
  _position_solution_flag_type position_solution_flag;

   typedef uint8_t _position_fixed_flag_type;
  _position_fixed_flag_type position_fixed_flag;

   typedef uint8_t _clock_steering_status_type;
  _clock_steering_status_type clock_steering_status;

   typedef uint8_t _clock_model_flag_type;
  _clock_model_flag_type clock_model_flag;

   typedef uint8_t _external_oscillator_locked_flag_type;
  _external_oscillator_locked_flag_type external_oscillator_locked_flag;

   typedef uint8_t _software_resource_type;
  _software_resource_type software_resource;

   typedef uint8_t _status_error_format_version_bit_type;
  _status_error_format_version_bit_type status_error_format_version_bit;

   typedef uint8_t _version_bit_1_type;
  _version_bit_1_type version_bit_1;

   typedef uint8_t _tracking_mode_type;
  _tracking_mode_type tracking_mode;

   typedef uint8_t _digital_filtering_enabled_type;
  _digital_filtering_enabled_type digital_filtering_enabled;

   typedef uint8_t _auxiliary_3_status_event_flag_type;
  _auxiliary_3_status_event_flag_type auxiliary_3_status_event_flag;

   typedef uint8_t _auxiliary_2_status_event_flag_type;
  _auxiliary_2_status_event_flag_type auxiliary_2_status_event_flag;

   typedef uint8_t _auxiliary_1_status_event_flag_type;
  _auxiliary_1_status_event_flag_type auxiliary_1_status_event_flag;



// reducing the odds to have name collisions with Windows.h 
#if defined(_WIN32) && defined(OK)
  #undef OK
#endif
#if defined(_WIN32) && defined(Valid)
  #undef Valid
#endif
#if defined(_WIN32) && defined(No_error)
  #undef No_error
#endif
#if defined(_WIN32) && defined(No_overrun)
  #undef No_overrun
#endif
#if defined(_WIN32) && defined(Warning)
  #undef Warning
#endif
#if defined(_WIN32) && defined(Error)
  #undef Error
#endif
#if defined(_WIN32) && defined(Failure)
  #undef Failure
#endif
#if defined(_WIN32) && defined(Overrun)
  #undef Overrun
#endif
#if defined(_WIN32) && defined(Invalid)
  #undef Invalid
#endif
#if defined(_WIN32) && defined(Within_specifications)
  #undef Within_specifications
#endif
#if defined(_WIN32) && defined(Powered)
  #undef Powered
#endif
#if defined(_WIN32) && defined(Not_powered)
  #undef Not_powered
#endif
#if defined(_WIN32) && defined(Open_and_Antenna_disconnected)
  #undef Open_and_Antenna_disconnected
#endif
#if defined(_WIN32) && defined(Short_circuit_detected)
  #undef Short_circuit_detected
#endif
#if defined(_WIN32) && defined(No_overload)
  #undef No_overload
#endif
#if defined(_WIN32) && defined(Overload)
  #undef Overload
#endif
#if defined(_WIN32) && defined(Not_detected)
  #undef Not_detected
#endif
#if defined(_WIN32) && defined(Detected)
  #undef Detected
#endif
#if defined(_WIN32) && defined(Out_of_range)
  #undef Out_of_range
#endif
#if defined(_WIN32) && defined(Jammer_Detected)
  #undef Jammer_Detected
#endif
#if defined(_WIN32) && defined(No_INS_reset)
  #undef No_INS_reset
#endif
#if defined(_WIN32) && defined(INS_reset)
  #undef INS_reset
#endif
#if defined(_WIN32) && defined(No_IMU_communication)
  #undef No_IMU_communication
#endif
#if defined(_WIN32) && defined(Not_fixed)
  #undef Not_fixed
#endif
#if defined(_WIN32) && defined(Fixed)
  #undef Fixed
#endif
#if defined(_WIN32) && defined(Enabled_clock_steering)
  #undef Enabled_clock_steering
#endif
#if defined(_WIN32) && defined(Disabled_clock_steering)
  #undef Disabled_clock_steering
#endif
#if defined(_WIN32) && defined(UnLocked)
  #undef UnLocked
#endif
#if defined(_WIN32) && defined(Locked)
  #undef Locked
#endif
#if defined(_WIN32) && defined(OEM6_or_earlier_format)
  #undef OEM6_or_earlier_format
#endif
#if defined(_WIN32) && defined(OEM7_format)
  #undef OEM7_format
#endif
#if defined(_WIN32) && defined(Normal_tracking)
  #undef Normal_tracking
#endif
#if defined(_WIN32) && defined(HDR_tracking)
  #undef HDR_tracking
#endif
#if defined(_WIN32) && defined(Disables_digital_filtering)
  #undef Disables_digital_filtering
#endif
#if defined(_WIN32) && defined(Enables_digital_filtering)
  #undef Enables_digital_filtering
#endif
#if defined(_WIN32) && defined(No_event)
  #undef No_event
#endif
#if defined(_WIN32) && defined(Event)
  #undef Event
#endif


  static const uint8_t OK;
  static const uint8_t Valid;
  static const uint8_t No_error;
  static const uint8_t No_overrun;
  static const uint8_t Warning;
  static const uint8_t Error;
  static const uint8_t Failure;
  static const uint8_t Overrun;
  static const uint8_t Invalid;
  static const uint8_t Within_specifications;
  static const uint8_t Powered;
  static const uint8_t Not_powered;
  static const uint8_t Open_and_Antenna_disconnected;
  static const uint8_t Short_circuit_detected;
  static const uint8_t No_overload;
  static const uint8_t Overload;
  static const uint8_t Not_detected;
  static const uint8_t Detected;
  static const uint8_t Out_of_range;
  static const uint8_t Jammer_Detected;
  static const uint8_t No_INS_reset;
  static const uint8_t INS_reset;
  static const uint8_t No_IMU_communication;
  static const uint8_t Not_fixed;
  static const uint8_t Fixed;
  static const uint8_t Enabled_clock_steering;
  static const uint8_t Disabled_clock_steering;
  static const uint8_t UnLocked;
  static const uint8_t Locked;
  static const uint8_t OEM6_or_earlier_format;
  static const uint8_t OEM7_format;
  static const uint8_t Normal_tracking;
  static const uint8_t HDR_tracking;
  static const uint8_t Disables_digital_filtering;
  static const uint8_t Enables_digital_filtering;
  static const uint8_t No_event;
  static const uint8_t Event;

  typedef boost::shared_ptr< ::integrated_navigation_reader::Log_ReceiverStatus_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::integrated_navigation_reader::Log_ReceiverStatus_<ContainerAllocator> const> ConstPtr;

}; // struct Log_ReceiverStatus_

typedef ::integrated_navigation_reader::Log_ReceiverStatus_<std::allocator<void> > Log_ReceiverStatus;

typedef boost::shared_ptr< ::integrated_navigation_reader::Log_ReceiverStatus > Log_ReceiverStatusPtr;
typedef boost::shared_ptr< ::integrated_navigation_reader::Log_ReceiverStatus const> Log_ReceiverStatusConstPtr;

// constants requiring out of line definition

   
   template<typename ContainerAllocator> const uint8_t
      Log_ReceiverStatus_<ContainerAllocator>::OK =
        
           0
        
        ;
   

   
   template<typename ContainerAllocator> const uint8_t
      Log_ReceiverStatus_<ContainerAllocator>::Valid =
        
           0
        
        ;
   

   
   template<typename ContainerAllocator> const uint8_t
      Log_ReceiverStatus_<ContainerAllocator>::No_error =
        
           0
        
        ;
   

   
   template<typename ContainerAllocator> const uint8_t
      Log_ReceiverStatus_<ContainerAllocator>::No_overrun =
        
           0
        
        ;
   

   
   template<typename ContainerAllocator> const uint8_t
      Log_ReceiverStatus_<ContainerAllocator>::Warning =
        
           1
        
        ;
   

   
   template<typename ContainerAllocator> const uint8_t
      Log_ReceiverStatus_<ContainerAllocator>::Error =
        
           1
        
        ;
   

   
   template<typename ContainerAllocator> const uint8_t
      Log_ReceiverStatus_<ContainerAllocator>::Failure =
        
           1
        
        ;
   

   
   template<typename ContainerAllocator> const uint8_t
      Log_ReceiverStatus_<ContainerAllocator>::Overrun =
        
           1
        
        ;
   

   
   template<typename ContainerAllocator> const uint8_t
      Log_ReceiverStatus_<ContainerAllocator>::Invalid =
        
           1
        
        ;
   

   
   template<typename ContainerAllocator> const uint8_t
      Log_ReceiverStatus_<ContainerAllocator>::Within_specifications =
        
           0
        
        ;
   

   
   template<typename ContainerAllocator> const uint8_t
      Log_ReceiverStatus_<ContainerAllocator>::Powered =
        
           0
        
        ;
   

   
   template<typename ContainerAllocator> const uint8_t
      Log_ReceiverStatus_<ContainerAllocator>::Not_powered =
        
           1
        
        ;
   

   
   template<typename ContainerAllocator> const uint8_t
      Log_ReceiverStatus_<ContainerAllocator>::Open_and_Antenna_disconnected =
        
           1
        
        ;
   

   
   template<typename ContainerAllocator> const uint8_t
      Log_ReceiverStatus_<ContainerAllocator>::Short_circuit_detected =
        
           1
        
        ;
   

   
   template<typename ContainerAllocator> const uint8_t
      Log_ReceiverStatus_<ContainerAllocator>::No_overload =
        
           0
        
        ;
   

   
   template<typename ContainerAllocator> const uint8_t
      Log_ReceiverStatus_<ContainerAllocator>::Overload =
        
           1
        
        ;
   

   
   template<typename ContainerAllocator> const uint8_t
      Log_ReceiverStatus_<ContainerAllocator>::Not_detected =
        
           0
        
        ;
   

   
   template<typename ContainerAllocator> const uint8_t
      Log_ReceiverStatus_<ContainerAllocator>::Detected =
        
           1
        
        ;
   

   
   template<typename ContainerAllocator> const uint8_t
      Log_ReceiverStatus_<ContainerAllocator>::Out_of_range =
        
           1
        
        ;
   

   
   template<typename ContainerAllocator> const uint8_t
      Log_ReceiverStatus_<ContainerAllocator>::Jammer_Detected =
        
           1
        
        ;
   

   
   template<typename ContainerAllocator> const uint8_t
      Log_ReceiverStatus_<ContainerAllocator>::No_INS_reset =
        
           0
        
        ;
   

   
   template<typename ContainerAllocator> const uint8_t
      Log_ReceiverStatus_<ContainerAllocator>::INS_reset =
        
           1
        
        ;
   

   
   template<typename ContainerAllocator> const uint8_t
      Log_ReceiverStatus_<ContainerAllocator>::No_IMU_communication =
        
           1
        
        ;
   

   
   template<typename ContainerAllocator> const uint8_t
      Log_ReceiverStatus_<ContainerAllocator>::Not_fixed =
        
           0
        
        ;
   

   
   template<typename ContainerAllocator> const uint8_t
      Log_ReceiverStatus_<ContainerAllocator>::Fixed =
        
           1
        
        ;
   

   
   template<typename ContainerAllocator> const uint8_t
      Log_ReceiverStatus_<ContainerAllocator>::Enabled_clock_steering =
        
           0
        
        ;
   

   
   template<typename ContainerAllocator> const uint8_t
      Log_ReceiverStatus_<ContainerAllocator>::Disabled_clock_steering =
        
           1
        
        ;
   

   
   template<typename ContainerAllocator> const uint8_t
      Log_ReceiverStatus_<ContainerAllocator>::UnLocked =
        
           0
        
        ;
   

   
   template<typename ContainerAllocator> const uint8_t
      Log_ReceiverStatus_<ContainerAllocator>::Locked =
        
           1
        
        ;
   

   
   template<typename ContainerAllocator> const uint8_t
      Log_ReceiverStatus_<ContainerAllocator>::OEM6_or_earlier_format =
        
           0
        
        ;
   

   
   template<typename ContainerAllocator> const uint8_t
      Log_ReceiverStatus_<ContainerAllocator>::OEM7_format =
        
           1
        
        ;
   

   
   template<typename ContainerAllocator> const uint8_t
      Log_ReceiverStatus_<ContainerAllocator>::Normal_tracking =
        
           0
        
        ;
   

   
   template<typename ContainerAllocator> const uint8_t
      Log_ReceiverStatus_<ContainerAllocator>::HDR_tracking =
        
           1
        
        ;
   

   
   template<typename ContainerAllocator> const uint8_t
      Log_ReceiverStatus_<ContainerAllocator>::Disables_digital_filtering =
        
           0
        
        ;
   

   
   template<typename ContainerAllocator> const uint8_t
      Log_ReceiverStatus_<ContainerAllocator>::Enables_digital_filtering =
        
           1
        
        ;
   

   
   template<typename ContainerAllocator> const uint8_t
      Log_ReceiverStatus_<ContainerAllocator>::No_event =
        
           0
        
        ;
   

   
   template<typename ContainerAllocator> const uint8_t
      Log_ReceiverStatus_<ContainerAllocator>::Event =
        
           1
        
        ;
   



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::integrated_navigation_reader::Log_ReceiverStatus_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::integrated_navigation_reader::Log_ReceiverStatus_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::integrated_navigation_reader::Log_ReceiverStatus_<ContainerAllocator1> & lhs, const ::integrated_navigation_reader::Log_ReceiverStatus_<ContainerAllocator2> & rhs)
{
  return lhs.error_flag == rhs.error_flag &&
    lhs.temperature_status == rhs.temperature_status &&
    lhs.voltage_supply_status == rhs.voltage_supply_status &&
    lhs.primary_antenna_power_status == rhs.primary_antenna_power_status &&
    lhs.LNA_failure == rhs.LNA_failure &&
    lhs.primary_antenna_open_circuit_flag == rhs.primary_antenna_open_circuit_flag &&
    lhs.primary_antenna_short_circuit_flag == rhs.primary_antenna_short_circuit_flag &&
    lhs.CPU_overload_flag == rhs.CPU_overload_flag &&
    lhs.COM_port_transmit_buffer_overrun == rhs.COM_port_transmit_buffer_overrun &&
    lhs.spoofing_detection_status == rhs.spoofing_detection_status &&
    lhs.reserved == rhs.reserved &&
    lhs.link_overrun_flag == rhs.link_overrun_flag &&
    lhs.input_overrun_flag == rhs.input_overrun_flag &&
    lhs.aux_transmit_overrun_flag == rhs.aux_transmit_overrun_flag &&
    lhs.antenna_gain_state == rhs.antenna_gain_state &&
    lhs.jammer_detected == rhs.jammer_detected &&
    lhs.INS_reset_flag == rhs.INS_reset_flag &&
    lhs.IMU_communication_failure == rhs.IMU_communication_failure &&
    lhs.GPS_almanac_flag_UTC_known == rhs.GPS_almanac_flag_UTC_known &&
    lhs.position_solution_flag == rhs.position_solution_flag &&
    lhs.position_fixed_flag == rhs.position_fixed_flag &&
    lhs.clock_steering_status == rhs.clock_steering_status &&
    lhs.clock_model_flag == rhs.clock_model_flag &&
    lhs.external_oscillator_locked_flag == rhs.external_oscillator_locked_flag &&
    lhs.software_resource == rhs.software_resource &&
    lhs.status_error_format_version_bit == rhs.status_error_format_version_bit &&
    lhs.version_bit_1 == rhs.version_bit_1 &&
    lhs.tracking_mode == rhs.tracking_mode &&
    lhs.digital_filtering_enabled == rhs.digital_filtering_enabled &&
    lhs.auxiliary_3_status_event_flag == rhs.auxiliary_3_status_event_flag &&
    lhs.auxiliary_2_status_event_flag == rhs.auxiliary_2_status_event_flag &&
    lhs.auxiliary_1_status_event_flag == rhs.auxiliary_1_status_event_flag;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::integrated_navigation_reader::Log_ReceiverStatus_<ContainerAllocator1> & lhs, const ::integrated_navigation_reader::Log_ReceiverStatus_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace integrated_navigation_reader

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsFixedSize< ::integrated_navigation_reader::Log_ReceiverStatus_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::integrated_navigation_reader::Log_ReceiverStatus_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::integrated_navigation_reader::Log_ReceiverStatus_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::integrated_navigation_reader::Log_ReceiverStatus_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::integrated_navigation_reader::Log_ReceiverStatus_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::integrated_navigation_reader::Log_ReceiverStatus_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::integrated_navigation_reader::Log_ReceiverStatus_<ContainerAllocator> >
{
  static const char* value()
  {
    return "5b24d026e25c2c7d69a340f45014905d";
  }

  static const char* value(const ::integrated_navigation_reader::Log_ReceiverStatus_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x5b24d026e25c2c7dULL;
  static const uint64_t static_value2 = 0x69a340f45014905dULL;
};

template<class ContainerAllocator>
struct DataType< ::integrated_navigation_reader::Log_ReceiverStatus_<ContainerAllocator> >
{
  static const char* value()
  {
    return "integrated_navigation_reader/Log_ReceiverStatus";
  }

  static const char* value(const ::integrated_navigation_reader::Log_ReceiverStatus_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::integrated_navigation_reader::Log_ReceiverStatus_<ContainerAllocator> >
{
  static const char* value()
  {
    return "# Receiver status - page 858\n"
"\n"
"bool OK = 0\n"
"bool Valid = 0\n"
"bool No_error = 0\n"
"bool No_overrun = 0\n"
"\n"
"bool Warning = 1\n"
"bool Error = 1\n"
"bool Failure = 1\n"
"bool Overrun = 1\n"
"bool Invalid = 1\n"
"\n"
"# N0\n"
"bool error_flag\n"
"\n"
"bool Within_specifications = 0\n"
"bool temperature_status\n"
"bool voltage_supply_status\n"
"\n"
"bool Powered = 0\n"
"bool Not_powered = 1\n"
"bool primary_antenna_power_status\n"
"\n"
"# N1\n"
"bool LNA_failure\n"
"\n"
"bool Open_and_Antenna_disconnected = 1\n"
"bool primary_antenna_open_circuit_flag\n"
"\n"
"bool Short_circuit_detected = 1\n"
"bool primary_antenna_short_circuit_flag\n"
"\n"
"bool No_overload = 0\n"
"bool Overload = 1\n"
"bool CPU_overload_flag\n"
"\n"
"# N2\n"
"bool COM_port_transmit_buffer_overrun\n"
"\n"
"bool Not_detected = 0\n"
"bool Detected = 1\n"
"bool spoofing_detection_status\n"
"\n"
"bool reserved\n"
"bool link_overrun_flag\n"
"\n"
"# N3\n"
"bool input_overrun_flag\n"
"bool aux_transmit_overrun_flag\n"
"\n"
"bool Out_of_range = 1\n"
"bool antenna_gain_state\n"
"\n"
"bool Jammer_Detected = 1\n"
"bool jammer_detected\n"
"\n"
"# N4\n"
"bool No_INS_reset = 0\n"
"bool INS_reset = 1\n"
"bool INS_reset_flag\n"
"\n"
"bool No_IMU_communication = 1\n"
"bool IMU_communication_failure\n"
"\n"
"bool GPS_almanac_flag_UTC_known\n"
"bool position_solution_flag\n"
"\n"
"# N5\n"
"bool Not_fixed = 0\n"
"bool Fixed = 1\n"
"bool position_fixed_flag\n"
"\n"
"bool Enabled_clock_steering = 0\n"
"bool Disabled_clock_steering = 1\n"
"bool clock_steering_status\n"
"\n"
"bool clock_model_flag\n"
"\n"
"bool UnLocked = 0\n"
"bool Locked = 1\n"
"bool external_oscillator_locked_flag\n"
"\n"
"# N6\n"
"bool software_resource\n"
"\n"
"bool OEM6_or_earlier_format = 0\n"
"bool OEM7_format = 1\n"
"bool status_error_format_version_bit\n"
"\n"
"bool version_bit_1\n"
"\n"
"bool Normal_tracking = 0\n"
"bool HDR_tracking = 1\n"
"bool tracking_mode\n"
"\n"
"# N7\n"
"bool Disables_digital_filtering = 0\n"
"bool Enables_digital_filtering = 1\n"
"bool digital_filtering_enabled\n"
"\n"
"bool No_event = 0\n"
"bool Event = 1\n"
"bool auxiliary_3_status_event_flag\n"
"bool auxiliary_2_status_event_flag\n"
"bool auxiliary_1_status_event_flag\n"
;
  }

  static const char* value(const ::integrated_navigation_reader::Log_ReceiverStatus_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::integrated_navigation_reader::Log_ReceiverStatus_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.error_flag);
      stream.next(m.temperature_status);
      stream.next(m.voltage_supply_status);
      stream.next(m.primary_antenna_power_status);
      stream.next(m.LNA_failure);
      stream.next(m.primary_antenna_open_circuit_flag);
      stream.next(m.primary_antenna_short_circuit_flag);
      stream.next(m.CPU_overload_flag);
      stream.next(m.COM_port_transmit_buffer_overrun);
      stream.next(m.spoofing_detection_status);
      stream.next(m.reserved);
      stream.next(m.link_overrun_flag);
      stream.next(m.input_overrun_flag);
      stream.next(m.aux_transmit_overrun_flag);
      stream.next(m.antenna_gain_state);
      stream.next(m.jammer_detected);
      stream.next(m.INS_reset_flag);
      stream.next(m.IMU_communication_failure);
      stream.next(m.GPS_almanac_flag_UTC_known);
      stream.next(m.position_solution_flag);
      stream.next(m.position_fixed_flag);
      stream.next(m.clock_steering_status);
      stream.next(m.clock_model_flag);
      stream.next(m.external_oscillator_locked_flag);
      stream.next(m.software_resource);
      stream.next(m.status_error_format_version_bit);
      stream.next(m.version_bit_1);
      stream.next(m.tracking_mode);
      stream.next(m.digital_filtering_enabled);
      stream.next(m.auxiliary_3_status_event_flag);
      stream.next(m.auxiliary_2_status_event_flag);
      stream.next(m.auxiliary_1_status_event_flag);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct Log_ReceiverStatus_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::integrated_navigation_reader::Log_ReceiverStatus_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::integrated_navigation_reader::Log_ReceiverStatus_<ContainerAllocator>& v)
  {
    s << indent << "error_flag: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.error_flag);
    s << indent << "temperature_status: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.temperature_status);
    s << indent << "voltage_supply_status: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.voltage_supply_status);
    s << indent << "primary_antenna_power_status: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.primary_antenna_power_status);
    s << indent << "LNA_failure: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.LNA_failure);
    s << indent << "primary_antenna_open_circuit_flag: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.primary_antenna_open_circuit_flag);
    s << indent << "primary_antenna_short_circuit_flag: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.primary_antenna_short_circuit_flag);
    s << indent << "CPU_overload_flag: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.CPU_overload_flag);
    s << indent << "COM_port_transmit_buffer_overrun: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.COM_port_transmit_buffer_overrun);
    s << indent << "spoofing_detection_status: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.spoofing_detection_status);
    s << indent << "reserved: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.reserved);
    s << indent << "link_overrun_flag: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.link_overrun_flag);
    s << indent << "input_overrun_flag: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.input_overrun_flag);
    s << indent << "aux_transmit_overrun_flag: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.aux_transmit_overrun_flag);
    s << indent << "antenna_gain_state: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.antenna_gain_state);
    s << indent << "jammer_detected: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.jammer_detected);
    s << indent << "INS_reset_flag: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.INS_reset_flag);
    s << indent << "IMU_communication_failure: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.IMU_communication_failure);
    s << indent << "GPS_almanac_flag_UTC_known: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.GPS_almanac_flag_UTC_known);
    s << indent << "position_solution_flag: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.position_solution_flag);
    s << indent << "position_fixed_flag: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.position_fixed_flag);
    s << indent << "clock_steering_status: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.clock_steering_status);
    s << indent << "clock_model_flag: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.clock_model_flag);
    s << indent << "external_oscillator_locked_flag: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.external_oscillator_locked_flag);
    s << indent << "software_resource: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.software_resource);
    s << indent << "status_error_format_version_bit: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.status_error_format_version_bit);
    s << indent << "version_bit_1: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.version_bit_1);
    s << indent << "tracking_mode: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.tracking_mode);
    s << indent << "digital_filtering_enabled: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.digital_filtering_enabled);
    s << indent << "auxiliary_3_status_event_flag: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.auxiliary_3_status_event_flag);
    s << indent << "auxiliary_2_status_event_flag: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.auxiliary_2_status_event_flag);
    s << indent << "auxiliary_1_status_event_flag: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.auxiliary_1_status_event_flag);
  }
};

} // namespace message_operations
} // namespace ros

#endif // INTEGRATED_NAVIGATION_READER_MESSAGE_LOG_RECEIVERSTATUS_H
